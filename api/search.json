[{"id":"8dd3630db64a202bd3f3cf23aa85f427","title":"Linux调试工具gdb","content":"\n\n\n\n\n\n\n\n\n\n\nLinux入门，如何在Linux中调试代码。\n\ngdb 调试工具\n\n\n\n\n\n\n\n\ngdb就是一款调试器，只负责程序的调试\ngcc:默认是以release方式进行发布的！ 不可以被调试\nrelease：一般软件进行发布，交付给用户的模式\ndebug：生成的软件内部，是包含了调试信息 体积上一定是大于release的\n要让gcc生成debug模式，如下：gcc命令添加-g即可，然后直接gdb(图有点问题，下面一条gcc也要加-g)\n\n\n\n\n\n\n\n\n\n读取可执行程序二进制构成readelf -S mybin_d扩展：可执行程序形成的时候，不是无顺序的二进制构成，有自己的格式的 – 可执行程序有自己的二进制格式 – ELF格式\n先gdb mybin_d 进入调试再l 看到代码(l 后可以跟数字)\nb 行号 打断点\nr 跑起来 断点处停止（没有就直接运行到结束）任意时候r都可以重新执行到第一个断点处\nn 一行一行走\ninfo b(i b) 查看断点\nd 跟断点编号，删除断点\ns 进入函数finish 退出函数\ndisplay 变量  查看变量（取地址也行\nundisplay 编号  可以取消\nuntil 行号  指定执行到这一行（非空行，否则向下执行到第一条非空行）\nc 直接到下一个断点\n","slug":"Linux调试器gdb","date":"2023-08-26T02:40:51.000Z","categories_index":"","tags_index":"Linux","author_index":"混游"},{"id":"c15a6d9fcbf8b632f0e318fd59515ff5","title":"Linux中打包压缩和解压缩 zip/unzip/tar","content":"\n\n\n\n\n\n\n\n\n\n\nLinux入门，如何在Linux中调试代码。\n\nzip&#x2F;unzip&#x2F;tar 打包压缩和解压缩\n\n\n\n\n\n\n\n\nzip -r text1.txt text.txt &#x2F;&#x2F;将text.txt压缩成text1.txt一般加-r递归压缩一整个目录unzip text1.txt 解压缩 \n也可以同目录下压缩多个文件到一起\n\n\n\n\n\n\n\n\n\nzip d.zip text.c main.c game.c 将后面三个压缩到d.zip\n\n\n\n\n\n\n\n\n\nunzip d.zip -d 路径  解压到指定目录\n\n\n\n\n\n\n\n\n\ntar czf file.tgz file.txt 压缩tar tzf file.tgz 预览压缩包里有什么tar xzf file.tgz 解压中间三个字母是解&#x2F;压缩方式tar xzf code.tgz -C 路径 解压到指定目录 \n\n\n\n\n\n\n\n\n\n.tar-打包后缀  .gz-压缩后缀 一步到位.tgz \n","slug":"Linux打包压缩和解压缩","date":"2023-08-26T02:40:51.000Z","categories_index":"","tags_index":"Linux","author_index":"混游"},{"id":"eabe4815c54214da6963b2b4ec736c27","title":"Linux编译器gcc/g++","content":"\n\n\n\n\n\n\n\n\n\n\nLinux入门，如何在Linux中编译代码。\n\ngcc&#x2F;g++\n\n\n\n\n\n\n\n\n从 .c  变成可执行文件1.预处理（头文件展开、去掉注释、宏替换、条件编译）2.编译 (把C变成汇编语言)3.汇编 （汇编变成.o目标二进制文件，二进制不可执行!）4.链接 (本质引入我们在代码中使用的第三方库) gcc会根据文件，默认进行链接（编译器和文件共同决定）\n\n\n\n\n\n\n\n\n\ngcc就是一款编译器，只负责程序的翻译 只识别.c文件（这里与linux系统对文件后缀不关心无关）编译完成指名：gcc test.c -o mybin只进行到预处理：gcc -E test.c -o test.i 且把结果放入test.i中只进行到编译: gcc -S test.c -o test.s 或者gcc -S test.i -o test.s只进行到汇编: gcc -c test.c -o test.o  想看二进制可以执行：od test.o执行到链接 gcc test.c&#x2F;test.o&#x2F;test.i&#x2F;test.s -o mybin\n\n\n\n\n\n\n\n\n\nESc 看键盘左上角 生成的中间文件 iso（一种镜像文件的后缀）\n\n\n\n\n\n\n\n\n\nlld mybin 可以查看可执行文件链接的库 libc-2.17.so 动态库 c库libc.a 静态库库真正名字，去掉前缀lib，去掉.XXXX，剩下的就是库名字\n\n\n\n\n\n\n\n\n\n当文件多的时候 最好先将多文件先统一编译成.o，再将所有.o链接成bin可执行程序文件超级多的时候用：make&#x2F;makefile\n\n\n\n\n\n\n\n\n\n\ngcc -E test.c -o test.i -DDEBUG 可以在命令行中给源代码定义宏DEBUG\n\nLinux: .so(动态库)  .a(静态库)windows：dll(动态库). .lib(静态库)\n库：\n\n\n\n\n\n\n\n\n\n库有自己的命名规则的：lib（前缀）name.so.XXX\n\n\n\n\n\n\n\n\n\n\n我们的.o和库是如何链接的？1.动态链接动态库是放在系统目录下的一个文件动态库不能缺少，一旦对应的动态库缺失，影响的可能会是多个程序。不能删除C库，Linux中基本上绝大部分指令都是链接C库的ldd + 可执行程序名    可以查看可执行程序链接的库2.静态链接编译器使用静态库进行静态链接的时候，会将自己的方法拷贝到目标程序中，该程序以后不用再以来静态库！删除静态库，不会影响程序\n\n在Linux中 gcc编译形成可执行程序，默认使用动态链接，提供动态库。\n\n\n\n\n\n\n\n\n\n如果需要改成静态链接\n\ngcc mytest.c -o mytest_static -static  (需要系统提供有静态库，一般下默认只装有动态库，没有静态库)静态链接形成的可执行程序明显体积变大了。\n\n\n\n\n\n\n\n\n\n\n安装C&#x2F;C++静态库yum install -y glibc-static libstdc++-static\n1.如果没有静态库，无法静态链接2.如果我们没有动态库，只有静态库，gcc能找到吗？ -能的，gcc默认优先动态链接 -tatic的本质，改变优先级且只适配静态链接。3.一个程序不一定是纯的动&#x2F;静态链接，有可能是混合的。 如果加了 -static就是要求全部变成静态链接\n\n\n\n\n\n\n\n\n\nfile + 可执行文件名   可以查看程序是静态链接还是动态链接\n\n\n\n\n\n\n\n\n\n动静态链接的优缺点动态库因为是共享库，有效的节省资源（磁盘空间，内存空间，网络空间等）【优点】动态库一旦缺失，导致各个程序都无法运行【缺点】静态库，不依赖库，程序可以独立运行【优点】，体积大，比较消耗资源【缺点】\nLinux项目自动化构建工具-make&#x2F;Makefilemake：他是一条命令makefile：是一个文件\n\n\n\n\n\n\n\n\n\n首先在目录下：touch Makefile&#x2F;makefile第二部编写makefile : vim makefile之后形成可执行程序就使用：make(这里直接make是扫描makefile文件中最顶头的一条语句)make完之后，再make是不会执行的（提高编译效率，避免重复编译,怎么做到的，根据源文件的时间比可执行文件要老。如果更改了源文件，则源文件的最近修改时间比可执行程序要新，再make就会生效），如果修改了.c源文件，再make就会重新生成目标文件\n\n\n\n\n\n\n\n\n\n如果加上一句 .PHONY:mybin  则make总是会被执行\n\n\n\n\n\n\n\n\n\n特殊符号$@(目标文件左边的) $^(依赖文件，冒号右边的)如果想要在执行命令时（make、make clean），不回显对应命令，则在命令前加上@符号即可   \n\n第一行是依赖关系，第二行是依赖方法，这两行格式必须如此mybin是目标文件 后面.c是依赖文件\n.PHONY ：可以理解为makefile的“关键字”，.PHONY : clean(伪目标)。总是被执行的！（依赖关系是否可以无障碍执行）\n\n\n\n\n\n\n\n\n\n然后需要生成可执行文件：make需要删除可执行文件：make clean\n\n\n\n\n\n\n\n\n\nmakefile1.依赖关系2.依赖方法 （二者通常缺一不可）\n目前这么用\n最终这么用\n\n\n\n\n\n\n\n\n\n这些命令之前加@ 就不会被打印出来\n\n\n\n\n\n\n\n\n\n$^:依赖文件列表$@:目标文件%.c:当前目录下的所有的.c文件展开%.o:对应的.c形成的.o$&lt;:%.c所代表的源文件，一个一个的拿出来，用gcc进行编译，形成同名的.o   \n\n缓冲区\n\n\n\n\n\n\n\n\n\n刷新策略：1.无缓冲（立即）2.行缓冲（\\n）3.全缓冲（缓冲区满的时候再刷新,磁盘我呢间file）4.程序退出，自动刷新\n\n\\r: 回到这一行开头fflush(stdout);这个函数可以立马刷新缓冲区\n\n\n","slug":"Linux编译器gcc:g++","date":"2023-08-24T12:53:51.000Z","categories_index":"","tags_index":"Linux","author_index":"混游"},{"id":"79192f4e418aae93ea4b91a4a8caaf50","title":"Linux编辑器vim","content":"\n\n\n\n\n\n\n\n\n\n\nLinux入门，如何在Linux中写代码。\n\nvim\n\n\n\n\n\n\n\n\nvim就是一款编辑器，只负责写代码\n\nvi 缩小版的vim \n\n\n\n\n\n\n\n\n\n\nvim是一款多模式的编辑器1.命令模式（默认）（输入都被当作命令）a&#x2F;i&#x2F;o&#x2F;s-&gt;2   shift+:-&gt;3$-&gt;到行尾^-&gt;定位到行首shift + g: (G) 定位文本结尾数字 + shift + g 定位到自定义行gg 定位文本开头b&#x2F;w 向前&#x2F;向后（跨词）找h&#x2F;j&#x2F;k&#x2F;l 左&#x2F;下&#x2F;上&#x2F;右yy 复制当前行 再p 粘贴 如果p之前输入数字，就粘贴数字那么多行u 撤销对撤销后悔 control + r14 yy 就是复制当前光标下 14行内容数字 dd 剪切光标开始数字行数字 x 删除 数字个字符shift + x&#x2F;(X) 往前删 也可以加数字数字 shift + ~ 可以批量化大小写转化数字 + r 批量化替换shift + r 可以直接输入，后续内容被直接替换，相当于win的inset\n\n\n\n\n\n\n\n\n\n2.插入模式（写代码）esc-&gt;1\n\n\n\n\n\n\n\n\n\n3.底行模式 w(保存) q（退出）wq（保存并退出） 后加！表示强制  esc-&gt;1  set nu (可以调出行号)反之 set nonu任何模式互相切换，都可以先切换到命令模式vs test1.c 再打开一个文件（没有的话自动创建） corl + ww可以将光标在两个文件中来回切换或者 corl + w（按完之后）h &#x2F; l可以左右切换！gcc test.c  直接编译vim中也可以 man 但是前面加！ \n\n\n\n\n\n\n\n\n\n\nlinux中加头文件甚至可以这样\n\n#include&lt;/usr/include/stdio.h&gt;\n配置vim\n\n\n\n\n\n\n\n\n\n所谓的vim基本配置，本质是将我们的配置项放入 用户～目录下 .vimrc 文件中或者直接GitHub上搜vimforcpp\n","slug":"Linux编辑器vim","date":"2023-08-24T10:53:51.000Z","categories_index":"","tags_index":"Linux","author_index":"混游"},{"id":"80c260dedfa35b3fef9448583fb68042","title":"Linux权限","content":"\n\n\n\n\n\n\n\n\n\n\nLinux入门，了解Linux的权限。\n\nLinux 权限\n\n\n\n\n\n\n\n\n日志 时间，日志等级 日志具体信息，其他信息\n\n\n\n\n\n\n\n\n\n权限: 一件事情是否允许你“做”文件的权限：file.txt -&gt; rwx1.属性：r, w, x2.人：文件的拥有者，文件的所属组，文件的other 文件属性有三块，分别对应三种人root 没有权限约束\n\n\n\n\n\n\n\n\n\n新建账户不能使用sudo：解决办法：用root账户再&#x2F;etc&#x2F;sudoers中添加白名单\n文件类型\n\n\n\n\n\n\n\n\nd:目录-:普通文件b:块设备（disk）c:字符设备（键盘，显示器）p:管道(计算机通信)s:socket文件l:链接文件\n修改文件权限\n\n\n\n\n\n\n\n\n\n🌰：chmod u+x file.txt🌰：chmod g-rwx file.txt🌰：chmod o+w file.txt🌰：chmod u-x,g+w,o-x file.txt \n\n🌰：chmod ugo+rwx file.txt🌰：chmod u+..,g+..,o+.. file.txt这两种一样\n\n还可以纯数据改权限🌰：chmod 666 file.txt数字是二进制\n\n\n\n\n\n\n\n\n\n\n\n更改文件的拥有者sudo chown root file.txt 改成root的sudo chgrp root file.txt 将所有组改成rootsudo chown xrj:xrj file.txt 将拥有者和所有组都改成xrj\n没有写权限，拥有者可以强制写\n\n\n\n\n\n\n\n\n\n进入一个目录需要什么权限 （x）r 影响我在目录查看此目录下的内容w 影响我在目录下创建&#x2F;更改&#x2F;删除文件的权利权限认证只能认证一个（u-&gt;g-&gt;o）umask 权限掩码000 000 010（2）（凡是在umask中出现的比特位，不会在最终的文件权限中出现）默认 普通666 最终 664 目录777 最终 775 umask 0001 可以改权限掩码 最终权限 &#x3D; 起始权限 &amp;（～umask）\n\n\n\n\n\n\n\n\n\n 用户目录权限是700(别人看不到也进不去) 有时候我们多个用户想进行文件数据共享(试过了，可以改用户目录的权限) 一个文件能否被删除，由这个文件所在目录决定 所以给目录加一个粘滞位（一般共享目录） chmod o+t 目录(此时大家都可以对自己文件的增删查改，但是不能互删) root 几乎万能\n\n\n\n\n\n\n\n\n\n根目录下有一个tmp目录就是共享目录\nyum\n\n\n\n\n\n\n\n\n功能 显示&#x2F;下载安装&#x2F;卸载\n\n\n\n\n\n\n\n\n\nsudo (search)list | grep name 查找yum install -y name 下载，解决依赖关系，安装yum remove name 卸载yum undate name 更新 \n","slug":"Linux权限","date":"2023-08-24T09:53:51.000Z","categories_index":"","tags_index":"Linux","author_index":"混游"},{"id":"bf7f037166129b300135505587b05fe9","title":"Linux管道命令","content":"\n\n\n\n\n\n\n\n\n\n\nLinux入门，了解Linux的管道命令。\n\n管道命令\n\n\n\n\n\n\n\n\n可以将一个命令处理的信息交给下一个命令\n\n\n\n\n\n\n\n\n\necho ‘1+2+3’ | bc 可以打印结果echo ‘1+2+3’ | bc &gt; file.txt 将结果输入到文件中 如果是追加 则要用 &gt;&gt;\n\n\n\n\n\n\n\n\n\n🌰： last | grep xrj | wc -l 查看xrj 登陆过多少次\n\n\n\n\n\n\n\n\n\ngrep ‘world’ test.c将包含world的行打印出来grep -v ‘world’ test.c将不包含world的行打印出来grep -i ‘world’ test.c 忽略大小写输出包含world的行\n\n\n\n\n\n\n\n\n\nlast 显示历史登陆信息last | head -5 显示头五个\n\n\n\n\n\n\n\n\n\nhead -1020 file.txt | tail -21 显示1000 - 1020\n在Linux中，命令，程序，工具统称为可执行程序\n\n\n\n\n\n\n\n\n\n如果想要自己指定编译出的文件名称🌰：gcc -o test test.c\n在系统中，可执行程序的搜索路径是保存在一个“全局”变量中，PATH，给系统提供命令的搜索路径。是环境变量的一个！\n\n\n\n\n\n\n\n\n\n在执行命令时，系统会在PATH中配置的路径中去寻找，找到了就执行，找不到就报 command not found\n\n\n\n\n\n\n\n\n\n所以我们自己的可执行程序也可以直接执行，需要将我们自己的可执行程序拷贝到PATH中配置的任意一个路径下(不建议)但是比较建议，把我们所在的可执行程序的路径配置到PATH中🌰： sudo cp a.out &#x2F;usr&#x2F;bin🌰：export PATH &#x3D; $PATH:路径\n\n\n\n\n\n\n\n\n\nsu&#x2F;su - 都是普通转root用户su 使用当前路径su - 直接跳转到root的家目录（&#x2F;root）\n","slug":"Linux管道命令","date":"2023-08-24T08:53:51.000Z","categories_index":"","tags_index":"Linux","author_index":"混游"},{"id":"d732435ba9ea8722d8141b107eb7d324","title":"Linux基本指令","content":"\n\n\n\n\n\n\n\n\n\n\nLinux入门了解Linux系统的基本命令\n\nLinux 基本指令\n\n\n\n\n\n\n\n\ncontrol + r 历史命令搜索history | tail -10 显示最新的历史10条命令reboot 重启指令\n\n\n\n\n\n\n\n\n\nls -l  &#x3D;&#x3D;  llls -F 可以显示文件类型which ls 可以查看指令的系统路径所以指令本身也是计算机上的一些程序（win中.exe或者可以执行的程序）\n\n\n\n\n\n\n\n\n\npwd 可以看当前路径\n\n\n\n\n\n\n\n\n\nalias 别名当使用which ls时会看到 (alias ls&#x3D;’ls –color&#x3D;auto’)所以直接输入ls –color&#x3D;auto和输入 ls 效果是一样的\n那我们还可以自己取别名\n\n\n\n\n\n\n\n\n\n例子 alias back&#x3D;’cd ..’\n\n\n\n\n\n\n\n\n\nwin中： 标识一个文件，文件名+后缀Linux中：一般文件名+后缀不是作为标识文件的主要方式，而是inode \n\n\n\n\n\n\n\n\n\n在Linux中 &#x2F; 有两种身份：1.一串路径的分隔符2.根目录\n基本上，所有的操作系统，组织文件的方式，都是“树”形结构，多叉树 Centos也是这样\n\n\n\n\n\n\n\n\n\n在任何情况下都可以通过 cd ～ 进入到当前用户目录下 (我的电脑cd也可以 )cd - 可以回到刚刚的那一目录里\n\n\n\n\n\n\n\n\n\ntouch 创建普通文件&#x2F;修改时间🌰：touch test.txt文件的属性不是文件的内容但是是数据stat 文件名（可以看到文件的所有属性）文件 &#x3D; 内容 + 属性最近更改是对内容的修改时间 （Modify）最近改动是对属性修改的时间 （Change）最近访问的时间(不会频繁更新以浪费资源) （Access）\n\n\n\n\n\n\n\n\n\nmkdir可以创建一批路径例如 mkdir -p 108&#x2F;xrj&#x2F;learnLinux\n\n\n\n\n\n\n\n\n\ntree可以将一个目录以树状结构显示出来默认情况下 Linux中没有tree命令安装命令时，切换到root账户输入：sudo yum install -y tree\n\n\n\n\n\n\n\n\n\nrmdir 只能删除空目录而rm -r 可以递归删除非空目录（但是会询问 我的mac不会询问）rm -rf 直接干掉\n\n\n\n\n\n\n\n\n\nsudo touch root.txt 创建属于root的文件但是这个文件普通用户可以删除他这里比较复杂，还和当前目录属于谁有关\n\n\n\n\n\n\n\n\n\n***切记：(sudo) rm -rf &#x2F; 这条命令永远不要执行 否则删库跑路 ***\n\n\n\n\n\n\n\n\n\n同时创建一百个文件count&#x3D;0; while [ $count -le 100 ]; do touch file$count;let count++; done输出一万行语句到一个文件中cnt&#x3D;1; while [ $cnt -le 10000 ]; do echo “hello world $cnt”; let cnt++; done &gt; file1\n\n\n\n\n\n\n\n\n\nls file* 可以看到这一百个文件这个 * 是通配符\n\n\n\n\n\n\n\n\n\nman 可以问系统中这个男人很多问题\n\n\n\n\n\n\n\n\n\necho “hello world” 可以输出到终端上如果echo “hello world” &gt; file.txt 则可以将文本输出到该文件中cat file.txt 可以查看该文件内容\n\n\n\n\n\n\n\n\n\ncp 可以拷贝文件🌰：cp file.txt .. 拷贝文件到上一个目录🌰：cp file.txt file.txt.bat 拷贝文件到当前目录并改文件名cp -r 可以拷贝一个路径🌰：cp -r 108 109 拷贝108 到当前目录，改名为109,如果存在109则拷贝到109当中，不改名 \n\n\n\n\n\n\n\n\n\nr 递归f 强制 \n\n\n\n\n\n\n\n\n\nmv 移动一个文件（还可以变相使用来改名）和 cp 类似 但是移动路径不需要-r如果移动时 mv -f 目录下有同名文件，不会询问，直接覆盖        mv -i        会询问 \n\n\n\n\n\n\n\n\n\ncat 显示文件内容(全部),且不可修改cat -n file.txt 会在显示时带行号cat -b flie.txt 不给空行带行号cat -s file.txt 不输出多行空行\ncat适合小文本more适合大文本推荐使用less\nmore -500 file.txt 直接看到500行继续输入&#x2F;6666 可以跳到第6666行\nhead -30 file.txt 显示前30行，默认是10行tail -30 file.txt 显示末尾30\n\n\n\n\n\n\n\n\n\ncat file.txt &gt; file1.txt这个是输出重定向，把内容输出到file1.txt中 但是这个是覆盖内容\n\ncat &lt; file.txt 可以打印file.txt的内容而追加需要用 &gt;&gt; 两个这个符号,如果需要不换行，把echo改成printf单独cat 会读到什么输出什么清空文件内容：&gt;file.txt\n\n\n\n\n\n\n\n\n\n\ntac 和cat类似但是是倒着打印\n\n\n\n\n\n\n\n\n\ndate 可以查看系统时间date +%s 可以查看当前时间戳价值：单项递增，不重复，比较适合作为一条关键性信息的索引值（键值）（日志）\n\n\n\n\n\n\n\n\n\n千年虫问题（了解）\n\n\n\n\n\n\n\n\n\n将一个时间戳转换成时间date +%Y:%m:%d-%H&#x2F;%M&#x2F;%S -d @时间戳cal 年份 查看这年日历\n\n\n\n\n\n\n\n\n\nping www.baidu.com 默认输出ping不停止，想要停止就 ctl cctrl + c : 终止前台异常程序（进程）\n\n\n\n\n\n\n\n\n\nifconfig 查看计算机的网络信息\n\n\n\n\n\n\n\n\n\n服务器是永远不关机的。虚拟机可以关机shutdown 关机\n\n\n\n\n\n\n\n\n\n用exit 来退出用户 或者control d\n\n\n\n\n\n\n\n\n\n如果命令忘记了，输入前几个字母快速tab两次，就会显示出来匹配的命令如果写的命令快完整了，tab后会自动补齐\n\n\n\n\n\n\n\n\n\nLinux &#x2F; 目录结构是有一定比爱准的， GHS，规定了各个目录都有它自己的特定功能\n\n\n\n\n\n\n\n\n\n🌰：find &#x2F;home -name test.c &gt; msg.txt 2&gt;&amp;1 （加上2&gt;&amp;1）不但可以将正确信息输入也可以将错误的输入\n\n\n\n\n\n\n\n\n\nuname -a 查看系统信息uname -r 查看Linux的体系结构默认只写x86就是32位系统 \n","slug":"Linux基本指令","date":"2023-08-24T07:53:51.000Z","categories_index":"","tags_index":"Linux","author_index":"混游"},{"id":"2fbaf603ec26bc8f2ff5a200aba43b13","title":"Linux入门","content":"\n\n\n\n\n\n\n\n\n\n\nLinux入门，了解Linux，以及如何拥有一个Linux操作系统并使用。\n\n什么是操作系统\n\n\n\n\n\n\n\n\n\n第一台计算机 埃尼阿克 1946-2-14操作系统是什么：使计算机更好用，这是操作系统的根本定义操作系统是一款软硬件管理的软件操作系统的核心工作：通过对下管理好软硬件资源的手段，达到对上提供良好的（稳定，快速，安全）操作&#x2F;使用环境\n\n\n\n\n\n\n\n\n\n赫尔辛基大学91-&gt;雷纳斯托瓦滋 适用了UNIX操作系统的电脑写了一个自己的操作系统demo-&gt;Linux （Linux is not unix） &amp;&amp; 源代码免费公开了安卓里就是Linux内核\n\n\n\n\n\n\n\n\n\n硬件-&gt;设备驱动-&gt;操作系统-&gt;应用软件\n\nLinux操作系统\n\n\n\n\n\n\n\n\n特点1.开源-大部分免费的，稳定，安全，高效2.更多的被专业的人所使用\n\n\n\n\n\n\n\n\n\nLinux的应用场景1.互联网公司的服务器后端2.智能设备中使用（手机，智能电视…）3.嵌入式场景….\n\n\n\n\n\n\n\n\n\nLinux 版本1.商业化版本线：ubuntu，CentOS…\n环境安装\n\n\n\n\n\n\n\n\n1.裸机安装或者双系统 – 不推荐2.虚拟机安装 — 不推荐3.云服务器 – 安装简单，维护成本低，未来学习效果好，在阿里云或者腾讯云等购买服务器\n\n\n\n\n\n\n\n\n\n多人共用服务器（在linux系统界面中输入以下命令）adduser xrj 添加用户passwd 123456  设置登录密码\n\n\n\n\n\n\n\n\n\n需要提供账号密码ssh &#120;&#114;&#106;&#64;&#x31;&#52;&#56;&#x2e;&#x31;&#54;&#x36;&#46;&#x39;&#x34;&#x2e;&#x37;&#56;(这串数字是自己服务器的公网ip地址)再输入密码(123456)\n\n\n\n\n\n\n\n\n\n重置密码passwd 654321\n\n\n\n\n\n\n\n\n\n清除账户userdel -r xrj\n未来我们用什么样的账号来学习呢建议每个同学给自己建立一个普通用户\n","slug":"Linux入门","date":"2023-08-24T06:53:51.000Z","categories_index":"","tags_index":"Linux","author_index":"混游"},{"id":"ef37fc3c9cf74252746b5b01e28a7cff","title":"掌控变量","content":"\n\n\n\n\n\n\n\n\n\n\n🐰作者简介：一位普通高校的在校学生，致力于提高自己的编程能力。\n🍌个人主页：[比昨天强一點的博客_CSDN博客-领域博主](https:&#x2F;&#x2F;c-p-p.blog.csdn.net&#x2F; &quot;比昨天强一點的博客_CSDN博客-领域博主&quot;)\n🍍系列专栏：[C语言从0到精通_比昨天强一點的博客-CSDN博客](https:&#x2F;&#x2F;blog.csdn.net&#x2F;m0_63125842&#x2F;category_12057278.html &quot;C语言从0到精通_比昨天强一點的博客-CSDN博客&quot;)\n🏷️学习格言：无人问津的日子，最是提高自己的好时机。\n\n\n本章目的: 仅此一篇，让你将分支语句搞的明明白白，熟稔于心。\n什么是分支语句？举一个栗子🌰：\n\n\n\n    如果你天天码代码，好好码代码，毕业之后进大厂、拿到好offer、赢取白富美。\n\n\n但是，如果不好好学习，毕业之后回家放牛。\n\n这就是选择语句，也叫分支语句。\n\nif-else语句到这里，我们介绍了什么是分支语句，那么我们来举栗子，分支语句该怎么使用。\n\n以上述为例我们看代码\n\n这种写法是没问题的，在if（表达式）之后如果不加代码块，那么这个if（表达式）只决定其后一条语句执不执行\n\nif(表达式)   “表达式”在C语言中， 非0为真，0为假 。\n那如果条件成立要执行多条语句该怎么办呢，这时我们需要用到代码块，举个栗子🌰：\n\n#include &lt;stdio.h&gt;\n\nint main()&#123;\n\n    if()&#123;\n\n        执行表达式1\n        执行表达式2\n    &#125;else&#123;\n\n        执行表达式3\n        执行表达式4\n    &#125;\n\n    return 0;\n&#125;\n\n这里的 一对   { }    就是代码块\n** 注：建议但凡用到if-else结构或者后续讲到的循环结构，都要带上&#123; &#125; 这是一个好的编程习惯。**\n\n\n\n    **举个栗子🌰：**\n\n****\n请你读一读这段代码，并告诉我输出结果是什么？\n没错，这个代码运行之后什么都不输出。\n所以，如果分支语句，总是不加上{}，代码的可读性不够好。\n**      如果有多种分支情况，又该如何做呢？很简单，请往下看**\n#include &lt;stdio.h&gt;\n\nint mian()&#123;\n\n    if()&#123;\n        执行语句\n\n    &#125;else if()&#123;\n        执行语句\n\n    &#125;else&#123;\n        执行语句\n\n    &#125;\n    return 0;\n&#125;\n\n\n\nelse if（）可根据具体情况来增减\n\n\nswitch语句\n\n\n\n\n\n\n\n\nswitch语句也是一种分支语句。\n常常用于多分支的情况。\n比如:\n1:功\n\n\n\n  0:受\n接下来看看switch长什么样子：\nswitch(常量表达式)&#123;\n\n        case 0: \n            printf(&quot;受\\n&quot;);\n            break;\n        case 1:\n            printf(&quot;功\\n&quot;);\n            break;\n        default:\n            printf(&quot;输入错误\\n&quot;);\n            break;\n&#125;\n\n\n\n这里的 break和default是做什么用的呢？\n\n\n\n\n\n\n\n\n\nbreak其实是为了跳出switch，如果没有break，程序将不做判断继续往下执行，直到遇到break。\nswitch(常量表达式)&#123;\n\n        case 0: \n            printf(&quot;受\\n&quot;);\n        case 1:\n            printf(&quot;功\\n&quot;);\n            break;\n        default:\n            printf(&quot;输入错误\\n&quot;);\n            break;\n&#125;\n\n\n\n如上，如果我们把第一个break去掉，那么这个代码将输出：\n受\n功\n所以一般我们不会省略break，但也不排除这种情况。\n\n\n\n\n\n\n\n\n\n\n假设，我们输入1-7的数字，来判断是工作日还是休息日，怎么做呢？\nswitch(常量表达式)&#123;\n\n    case 1:\n        printf(&quot;工作日\\n&quot;);\n        break;\n    case 2:\n        printf(&quot;工作日\\n&quot;);\n        break;\n    case 3:\n        printf(&quot;工作日\\n&quot;);\n        break;\n    case 4:\n        printf(&quot;工作日\\n&quot;);\n        break;\n    case 5:\n        printf(&quot;工作日\\n&quot;);\n        break;\n    case 6:\n        printf(&quot;休息日\\n&quot;);\n        break;\n    case 7:\n        printf(&quot;休息日\\n&quot;);\n        break;\n     defoult:\n        printf(&quot;输入错误\\n&quot;);\n        break;\n&#125;\n\n\n\n**        上述做法完全是可行的。但是还可以做一下改变，且看：**\nswitch(常量表达式)&#123;\n\n    case 1:\n    case 2:\n    case 3:\n    case 4:\n    case 5:\n        printf(&quot;工作日\\n&quot;);\n        break;\n    case 6:\n    case 7:\n        printf(&quot;休息日\\n&quot;);\n        break;\n    default:\n        printf(&quot;输入错误\\n&quot;);\n        break;\n\n&#125;\n\n\n\n\n\n\n\n\n\n\n那么default是什么呢？\ndefault就是当所有case 值与常量表达式不匹配时就会执行default子句里的内容。\n\n\n\n    注：建议，在使用switch时，都要加上default，这是一个好的编程习惯。\n","slug":"掌控变量 一篇足以","date":"2023-02-28T06:53:51.000Z","categories_index":"","tags_index":"C语言","author_index":"混游"},{"id":"15df77317634e495e1c0f843aee8d294","title":"Mac Clion无法调适的可能原因","content":"\n> 🐰作者简介：一位普通高校的在校学生，致力于提高自己的编程能力。\n🍌个人主页：[比昨天强一點的博客_CSDN博客-领域博主](https:&#x2F;&#x2F;c-p-p.blog.csdn.net&#x2F; &quot;比昨天强一點的博客_CSDN博客-领域博主&quot;)\n🍍系列专栏：[C语言从0到精通_比昨天强一點的博客-CSDN博客](https:&#x2F;&#x2F;blog.csdn.net&#x2F;m0_63125842&#x2F;category_12057278.html &quot;C语言从0到精通_比昨天强一點的博客-CSDN博客&quot;)\n🏷️学习格言：无人问津的日子，最是提高自己的好时机。\n\n\n     如果你在使用Clion进行debug时出现这种情况\n\n\n显示找不到host\n那么很有可能是你的本地hosts文件里的内容出现了问题\n\n首先打开你的**访达                  **\n快捷键Shift+Command+G查找文件，输入 &#x2F;etc&#x2F;hosts ，点击回车\n![](https:&#x2F;&#x2F;img-blog.csdnimg.cn&#x2F;59c9eaac4fa04ee58024113f5d9c7099.png)![]( &quot;点击并拖拽以移动&quot;)**编辑**\n\n接下来能够看到这样一个文件\n双击打开查看\n如果 与下图区别很大\n\n**那么问题应该就是出现在这里。接下来打开终端输入 **\n\n\n\n\n\n\n\n\n\n** sudo -s**\n输入密码。 回车\n将下面的内容全部复制并粘贴到前面的终端窗口中，回车确认。\n\n\n\n\n\n\n\n\n\n**cat &lt; &#x2F;etc&#x2F;hosts\nHost Databaselocalhost is used to configure the loopback interfacewhen the system is booting.  Do not change this entry.127.0.0.1       localhost\n255.255.255.255 broadcasthost\n::1             localhost\nEOF**\n最后再输入改命令到终端中\n\n\n\n\n\n\n\n\n\nsudo chown root:wheel &#x2F;etc&#x2F;hosts; sudo chmod 644 &#x2F;etc&#x2F;hosts\n再次双击打开hosts，文件内容就被修改为默认，再次进入Clion，就可以debug了。\n\n\n\n\n\n\n\n\n\n\n博主也是在使用中遇到了问题，找了很久，没有看到详细的教程，所以自己总结了一套，希望能够帮到你。\n","slug":"Mac-Clion无法调适","date":"2023-02-27T10:53:51.000Z","categories_index":"","tags_index":"Clion,Mac","author_index":"混游"},{"id":"7f367b0fa41ebe2c6c61fe40a4e92fbd","title":"浮点型","content":"\n\n\n\n\n\n\n\n\n\n\n🐰作者简介：一位普通高校的在校学生，致力于提高自己的编程能力。\n🍌个人主页：[比昨天强一點的博客_CSDN博客-领域博主](https:&#x2F;&#x2F;c-p-p.blog.csdn.net&#x2F; &quot;比昨天强一點的博客_CSDN博客-领域博主&quot;)\n🍍系列专栏：[C语言从0到精通_比昨天强一點的博客-CSDN博客](https:&#x2F;&#x2F;blog.csdn.net&#x2F;m0_63125842&#x2F;category_12057278.html &quot;C语言从0到精通_比昨天强一點的博客-CSDN博客&quot;)\n🏷️学习格言：无人问津的日子，最是提高自己的好时机。\n​         学过编程语言的都知道，浮点型是有精度问题的。（说人话它实际值与我们想要存入的的值是有细微误差的）。接下来我的讲解将让你对于浮点型的了解更加深入。\n废话不多说，先看一个例子。（基于C语言）c语言中浮点型有两种\n1.单精度浮点型（float）\n2.双精度浮点型（double）\n先看一段代码\n#include &lt;stdio.h&gt;\n\n\nint mian()&#123;\n\n    float a &#x3D; 0.1f; &#x2F;&#x2F;以单精度浮点型的方式初始化 单单一个小数，是会被默认为double类型的。\n    double b &#x3D; 0.1; \n\n    printf(&quot;%.30f\\n&quot;,a);&#x2F;&#x2F;以单精度浮点型输出并保留30位小数\n    printf(&quot;%.30lf\\n&quot;); &#x2F;&#x2F;以双精度浮点型输出并保留30位小数\n\n&#125;\n\n\n\n输出结果\n单单从结果上看，同是浮点型，double 和 float也是有区别的，而且可以看出double比float精度要高。\n接下来我来给大家解释一下浮点型为什么表现出这样的特性呢。首先看一段话\n浮点数在计算机内部的表现方法：根据国际标准IEEE（电气和电子工程协会）754，任意一个二进制浮点数V可以表示成下面的形式：\n(-1)^S M * 2^E*\n(-1)^s表示符号位，当S&#x3D;0，V为正数；当s&#x3D;1，V为负数。\nM表示有效数字，大于等于1，小于2。\n2^E表示指数位。\n举例来说：十进制的5.0，写成二进制是101.0，相当于1.01*2^2。那么，按照上面v的格式，可以得出s &#x3D; 0， M &#x3D; 1.01， E &#x3D; 2。\n十进制的-5.0，写成二进制是-101.0，相当于-1.01*2^2。那么，S &#x3D; 1，M &#x3D; 1.01， E &#x3D; 2。\n接下来我将用画图的方式给未来大🐮们讲解一下这个标准。\nEEE 754规定：对于32位的浮点数，最高的1位是符号位s，接着的8位是指数E，剩下的23位为有效数字M。\n如图：\n\n(-1)^S M * 2^E*IEEE 754对有效数字M和指数E，还有一些特别规定。前面说过，1&lt; M（有效数字）&lt;2，也就是说，M可以写成 1.xxxxxx 的形式，其中Xxxxxx表示小数部分。\nIEEE 754规定，在计算机内部保存M时，默认这个数的第一位总是1，因此可以被舍去，只保存后面的xxxx部分。比如保存1.01的时候，只保存01，等到读取的时候，再把第一位的1加上去。这样做的目的，是节省1位有效数字。(最初设计计算机的那帮人物，总是想方设法更有效的利用计算机)\n以32位浮点数为例，留给M只有23位，将第一位的1舍去以后，等于可以保存24位有效数字。（这样精度也就提高了， 数据相对更精确）。\n至于指数E，情况就比较复杂。\n首先，E为一个无符号整数（unsigned int ）这意味着，如果E为8位，它的取值范围为0-255；如果E为11位，它的取值范围为0~2047。但是，我们知道，科学计数法中的E是可以出现负数的，所以IEEE 754规定，存入内存时E的真实值必须再加上一个中间数，对于8位的E，这个中间数是127；对于11位的E，这个中间数是1023。比如，2^10的E 是10，所以保存成32位浮点数时，必须保存成10+127&#x3D;137，即10001001。（再比如十进制0.5 &#x3D; (-1)^0 * 1.0 * 2^-1  所以保存成32位浮点数时，必须保存成  -1 + 127 &#x3D; 126，即 01111110）。\n回归文章最初，我们以十进制0.1为例我们可以通过进制转换工具知道：如图\n \n转换结果我们又可以写成1.100110011…. * 2^-4 (对应于标准 S &#x3D; 0，M &#x3D; 1.100110011…. ， E（真实值） &#x3D; -4 )\n因为E的标准 所以E在内存中存储的是 -4 + 127 &#x3D; 123   对应的二进制 01111011\n所以在内存中十进制0.1以单精度浮点型（float）被存储为：如图\n重点：有效数字M末尾一位是要根据情况进位的（后一位为1则截断的位置要进位）\n\n对于有效数字M其实就是如下图（这串数字是十进制的0.1在二进制中的表现方式）\n\n到此我们对于单精度浮点数如何存就已经讲完了，接下来就是取出来。对于取：指数E从内存中取出还可以再分成三种情况：\nE不全为0或不全为1\n这时，浮点数就采用下面的规则表示，即指数E的计算值减去127（或1023），得到真实值，再将有效数字M前加上第一位的1。比如：0.5（1&#x2F;2）的二进制形式为0.1，由于规定正数部分必须为1，即将小数点右移1位， 则为1.0*2^（-1)，其阶码为-1+127&#x3D;126， 表示为01111110，而尾数1.0去掉整数部分为0，补齐0到23位 00000000000000000000000，则其二进制表示形式为：\n0 01111110 00000000000000000000000\nE全为0 （真实值 + 127 &#x3D;&#x3D; 0 ）\n这时，浮点数的指数E等于1-127（或者1-1023）即为真实值，有效数字M不再加上第一位的1，而是还原为 0。xxxxxx的小数。这样做是为了表示土0，以及接近于0的很小的数字。（真实值 为-127  也就是 2^-127 这个数非常非常的小）\nE全为1 （真实值 + 127 &#x3D;&#x3D; 255）\n这时，如果有效数字M全为0，表示正负无穷大（正负取决于符号位s）（真实值 为128  也就是 2^128 这个数非常非常的大）\n此时我们回归文章开头。#include &lt;stdio.h&gt;\n\n\nint mian()&#123;\n\n    float a &#x3D; 0.1f; &#x2F;&#x2F;以单精度浮点型的方式初始化 单单一个小数，是会被默认为double类型的。\n    double b &#x3D; 0.1; \n\n    printf(&quot;%.30f\\n&quot;,a);&#x2F;&#x2F;以单精度浮点型输出并保留30位小数\n    printf(&quot;%.30lf\\n&quot;); &#x2F;&#x2F;以双精度浮点型输出并保留30位小数\n\n&#125;\n\n\n\n输出结果\n十进制0.1以单精度浮点型（float）存储：\n\n我们计算一下这个二进制。\nS &#x3D; 0\nE &#x3D; 真实值 + 127 &#x3D; （二进制）01111011 &#x3D; 123   真实值 - 4\nM &#x3D; 1.10011001100110011001101 ( 1.有效数字)\n代入标准公式  (-1)^S M * 2^E  &#x3D;  2^-4 * M &#x3D;  0.000110011001100110011001101（二进制）*\n转换为十进制\n\n对比转换结果（四舍五入）和我们输出的第一行是一致的\n至此单精度浮点型在内存上的本质就讲完了。而对于双精度浮点型是雷同的。仅仅只是E（指数位）和M（有效数字）的位数不同。\n如图：\n可以看到双精度的有效数字位数非常的长有52位，这也就是双精度浮点型更精确的原因所在。\n而对于双精度浮点型的存取与单精度浮点型存取换汤不换药，所以我坚信你通过单精度的例子能够明白双精度如何存取。我就不再赘述。\n\n\n\n\n\n\n\n\n\n这是我第一次写博客，如果在布局排版或者其它方面有什么让您感到不舒服的地方，欢迎您指出，或者文章有讲的不好或者错误的地方，请您不吝赐教，指出我的错误，这将对我提供很大的帮助，谢谢！\n","slug":"浮点型","date":"2023-02-18T13:40:31.000Z","categories_index":"","tags_index":"C语言,数据类型","author_index":"混游"},{"id":"20fa7a80c246c3a1e3b3bbe114dc196d","title":"C语言，万字入门","content":"\n\n\n\n\n\n\n\n\n\n\n\n\n🐰作者简介：一位普通高校的在校学生，致力于提高自己的编程能力。\n🍌个人主页：[比昨天强一點的博客_CSDN博客-领域博主](https:&#x2F;&#x2F;c-p-p.blog.csdn.net&#x2F; &quot;比昨天强一點的博客_CSDN博客-领域博主&quot;)\n🍍系列专栏：[C语言从0到精通_比昨天强一點的博客-CSDN博客](https:&#x2F;&#x2F;blog.csdn.net&#x2F;m0_63125842&#x2F;category_12057278.html &quot;C语言从0到精通_比昨天强一點的博客-CSDN博客&quot;)\n🏷️学习格言：无人问津的日子，最是提高自己的好时机。\n\n**        本章目的：希望你能通过这篇文章基本了解C语言，但是不会太深入讲解，C语言进阶将会在本专栏后续文章中。**\n1.什么是C语言语言，顾名思义，应该是用来沟通的，对话的，人与人之间沟通，有用中文、英文等等。而C语言是什么呢，**C**语言其实是程序员与计算机进行沟通而使用的语言之一。\n\n\n\n\n\n\n\n\n\n\nC语言是一门通用计算机编程语言，广泛应用于底层开发。C语言的设计目标是提供一种能以简易 的方式编译、处理低级存储器、产生少量的机器码以及不需要任何运行环境支持便能运行的编程语\n\n\n\n 尽管C语言提供了许多低级处理的功能，但仍然保持着良好跨平台的特性，以一个标准规格写出的 C语言程序可在许多电脑平台上进行编译，甚至包含一些嵌入式处理器(单片机或称MCU)以及超级电脑等作业平台。\n\n\n\n 二十世纪八十年代，为了避免各开发厂商用的C语言语法产生差异，由美国国家标准局为C语言制定了一套完整的美国国家标准语法，称为ANSI C，作为C语言最初的标准。 [1] 目前2011年12月8日，国际标准化组织(ISO)和国际电工委员会(IEC)发布的C11标准是C语言的第三个官方标准，也是C语言的最新标准，该标准更好的支持了汉字函数名和汉字标识符，一定程度上实现了汉字编程。\n\n\n\n C语言是一门面向过程的计算机编程语言，与C++，Java等面向对象的编程语言有所不同。 其编译器主要有Clang、GCC、WIN-TC、SUBLIME、MSVC、Turbo C、Clion等，苹、果系统有Xcode等。\n\n2.第一个C语言程序首先欢迎各位新人正式开始成为一位程序猿(![](https:&#x2F;&#x2F;img-blog.csdnimg.cn&#x2F;6b3ab25e329d49f6aa6743d7ade5ba2a.jpeg)![]( &quot;点击并拖拽以移动&quot;)**编辑**)\n\n\n那么我们来打印输出一个Hello World！（只会Hello World！）\n\n#include &lt;stdio.h&gt;\n\n\nint main()&#123;\n\n\n    printf(&quot;Hello World!&quot;);\n    \n    return 0;\n&#125;\n\n&#x2F;&#x2F;#include &lt;stdio.h&gt; 是头文件\n&#x2F;&#x2F;main是主函数，也是程序的入口，\n&#x2F;&#x2F;一个工程中，main函数有且只有一个\n\n\n\n这段代码运行会将 **Hello World！** 打印在屏幕上（如图）\n\n\n** 是不是很惊喜**\n\n\n3.数据类型C语言中有七大数据类型\n\n\n\n\n\n\n\n\n\n1.char           &#x2F;&#x2F;字符数据类型\n2.short          &#x2F;&#x2F;短整形\n3.int              &#x2F;&#x2F;整形\n4.long           &#x2F;&#x2F;长整形\n5.long long   &#x2F;&#x2F;更长的整形\n6.float           &#x2F;&#x2F;单精度浮点型\n7.double       &#x2F;&#x2F;双精度浮点型\n为什么有这么多种数据类型呢？\n答：是为了能够丰富的表达生活中的各种值\n每种类型的大小是多少？（多少个字节）\n&#x2F;&#x2F;以32位操作系统为例\n#include &lt;stdio.h&gt;\nint main()&#123;\n\n    printf(&quot;%d\\n&quot;, sizeof(int));           &#x2F;&#x2F;4\n    printf(&quot;%d\\n&quot;, sizeof(char));          &#x2F;&#x2F;1\n    printf(&quot;%d\\n&quot;, sizeof(short));         &#x2F;&#x2F;2\n    printf(&quot;%d\\n&quot;, sizeof(double));        &#x2F;&#x2F;8\n    printf(&quot;%d\\n&quot;, sizeof(float));         &#x2F;&#x2F;4\n    printf(&quot;%d\\n&quot;, sizeof(long long));     &#x2F;&#x2F;8\n    printf(&quot;%d\\n&quot;, sizeof(long));          &#x2F;&#x2F;4 但在64位操作系统占8个字节\n    printf(&quot;%d\\n&quot;, sizeof(long double));   &#x2F;&#x2F;8\n\n    return 0;\n&#125;\n\n\n\n数据类型如何使用呢？(举几个栗子🌰)\nchar ch &#x3D; &#39;a&#39;;\n\nint height &#x3D; 180;\n\ndouble wage &#x3D; 58888.0;  &#x2F;&#x2F;这就是大家的月薪🌹\n\n\n\n\n3.变量和常量\n\n\n\n\n\n\n\n\n**        生活中的有些值是不变的(比如:圆周率，性别，身份证号码，血型等等)有些值是可变的(比如：年龄，体重，薪资)不变的值，C语言中用常量的概念来表示，变得值C语言中用变量来表示。**\n3.1定义变量的方法int age &#x3D; 18;\nfloat weight &#x3D; 45.5f;\nchar ch &#x3D; &#39;w&#39;;\n\n\n\n3.2变量的命名\n只能由字母(包括大写和小写)、数字和下划线( _ )组成。\n不能以数字开头。\n长度不能超过63个字符。\n变量名中区分大小写的。\n变量名不能使用关键字。\n\n3.3 变量的分类\n局部变量\n全局变量\n\n#include &lt;stdio.h&gt;\n\n    \nint global &#x3D; 20; &#x2F;&#x2F;全局变量\n\nint main()&#123;\n\n    int local &#x3D; 10; &#x2F;&#x2F;局部变量\n    int global &#x3D; 30; &#x2F;&#x2F;局部变量（可以与全局变量重名，但是不推荐）\n\n    printf(&quot;%d\\n&quot;,global); &#x2F;&#x2F;打印30，当局部变量与全局变量名一致时，采用局部优先原则。\n\n    return 0; \n\n&#125;\n\n\n\n3.4变量的使用#include &lt;stdio.h&gt;\n\nint mian()&#123;\n\n    int num1 &#x3D; 0; \n    int num2 &#x3D; 0;  \n    int sum &#x3D; 0;  &#x2F;&#x2F;定义变量并初始化值0\n\n    scanf(&quot;%d%d&quot;,&amp;num1,&amp;num2);&#x2F;&#x2F;这是输入函数，可以在运行时自行输入num1，num2的值\n\n    sum &#x3D; num1 + num2; &#x2F;&#x2F;变量之间可以进行各种数学运算。\n    \n    printf(&quot;%d\\n&quot;,sum); &#x2F;&#x2F;假设输入num1为10，num2为20，则输出30。\n    \n    return 0;\n\n&#125;\n\n\n\n3.4 变量的作用域和生命周期作用域：\n\n\n\n\n\n\n\n\n\n作用域(scope)是程序设计概念，通常来说，一段程序代码中所用到的名字并不总是有效&#x2F;可用的，而限定这个名字的可用性的代码范围就是这个梗名字的作用域\n\n局部变量的作用域是变量所在的局部范围。\n全局变量的作用域是整个工程。\n\n生命周期：\n\n\n\n\n\n\n\n\n\n变量的生命周期指的是变量的创建到变量的销毁之间的一个时间段(或者说变量从创建到销毁中间的过程就是变量的整个生命周期)\n\n局部变量的生命周期是:进入作用域生命周期开始，出作用域生命周期结束。\n全局变量的生命周期是:整个程序的生命周期。\n\n3.5常量C语言中的常量和变量的定义的形式有所差异。\nC语言中的常量分为以下以下几种:\n\n字面常量\n枚举常量\n#define 定义的标识符常量\nconst 修饰的常变量\n\n我们一一举栗🌰\n\n#include &lt;stdio.h&gt;\n\n&#x2F;&#x2F;栗子🌰\n\nenmu Sex&#123;\n\n    MALE,    &#x2F;&#x2F;默认值是0\n    FEMALE,  &#x2F;&#x2F;1\n    UNKNOWN  &#x2F;&#x2F;2\n\n&#125;;\n\n&#x2F;&#x2F;括号中的MALE，FEMALE，UNKNOWN是枚举常量\n\n\n&#x2F;&#x2F;define定义的常量\n#define MAX 100 \n\nint main()&#123;\n\n    3.14 &#x2F;&#x2F;字面常量\n\n    &#x2F;&#x2F;const修饰的常变量\n    const float pie &#x3D; 3.14f;&#x2F;&#x2F;这是const修饰的常变量，不能直接修改，但是可以通过指针变量修改（后续会讲，这里不多赘述）\n\n\n\n&#125;\n\n\n\n\n4. 字符串+转义字符+注释4.1 字符串\n\n\n\n\n\n\n\n\n“Hello World!”\n这种由双引号，引起来的就是字符串，字符串的结束标志是一个\\0转译字符，在计算字符串长度时\\0是结束标志，不算做字符串内容。\n\n#include &lt;stdio.h&gt;\n\n\nint main()&#123;\n\n\n    char arr1[] &#x3D; &quot;Hello&quot;;\n    char arr2[] &#x3D; &#123;&#39;H&#39;,&#39;e&#39;,&#39;l&#39;,&#39;l&#39;,&#39;o&#39;&#125;;\n    char arr3[] &#x3D; &#123;&#39;H&#39;,&#39;e&#39;,&#39;l&#39;,&#39;l&#39;,&#39;o&#39;,&#39;\\0&#39;&#125;;\n\n\n    printf(&quot;%s\\n&quot;,arr1);&#x2F;&#x2F;输出 Hello\n    printf(&quot;%s\\n&quot;,arr2);  输出 乱码（因为没有\\0作为结束标志）\n    printf(&quot;%s\\n&quot;,arr3);  输出 Hello\n\n    return 0;\n\n&#125;\n\n\n\n4.2转义字符假设我们要在屏幕上打印一个目录: c:\\code\\test.c\n如下，如果我们这样写代码。\n\n#include &lt;stdio.h&gt;\n\nint main()&#123;\n\n    printf(&quot;c:\\code\\test.c&quot;);\n\n    return 0;\n&#125;\n\n\n\n当我以为我的代码没问题时……….等等\n\n他居然输出了这样一串\n\n\n这是为什么呢？😭\n这里就不得不提一下转义字符了。转义字符顾名思义就是转变意思。\n\n下面看一些转义字符。\n\n\n\n转义字符\n释义\n\n\n\n?\n在书写连续多个问号时使用，防止他们被解析成三字母词\n\n\n&#39;\n用于表示字符常量’\n\n\n&quot;\n用于表示一个字符串内部的双引号\n\n\n\\a\n警告字符，蜂鸣\n\n\n\\b\n退格符\n\n\n\\f\n进纸符\n\n\n\\n\n换行符\n\n\n\\r\n回车\n\n\n\\t\n水平制表符\n\n\n\\v\n垂直制表符\n\n\n\\ddd\nddd表示1-3个八进制数 如：\\130\n\n\n\\xdd\ndd表示1-2个十六进制数 如：\\x5a\n\n\n\\\n用于表示一个反斜杠，防止它被解释为一个转义序列符。\n\n\n\n5. 注释\n\n代码中有不需要的代码可以直接删除，也可以注释掉\n\n\n\n代码中有些代码比较难懂，可以加一下注释文字\n\n\n\n举几个栗子🌰\n#include &lt;stdio.h&gt;\n\n\n\n\nint mian()&#123;\n\n    int num1 &#x3D; 10;\n    int num2 &#x3D; 20;\n    int sum &#x3D; 0;\n    &#x2F;* C语言注释风格\n    int num1 &#x3D; 10;\n    int num2 &#x3D; 20;\n    *&#x2F;\n\n    \n    sum &#x3D; num1 + sum2; &#x2F;&#x2F;两数相加。C++注释风格\n\n&#125;\n\n\n\n\n6. 选择语句\n如果你好好学习，校招时拿一个好offer,赢取白富美，走上人生巅峰。 如果你不学习，毕业等于失业，工地搬砖。 这就是选择!（你看他笑的多开心（![](https:&#x2F;&#x2F;img-blog.csdnimg.cn&#x2F;6b3ab25e329d49f6aa6743d7ade5ba2a.jpeg)![]( &quot;点击并拖拽以移动&quot;)**编辑**））\n\n\n\n来看一段代码，你就知道if-else如何使用了\n#include &lt;stdio.h&gt;\n\nint main()&#123;\n\n\n    int choose &#x3D; 0;\n\n    printf(&quot;你会去敲代码吗？选择1 or 0&quot;);\n\n    scanf(&quot;%d&quot;,&amp;choose);\n\n    if(choose &#x3D;&#x3D; 1)&#123;\n        printf(&quot;老铁，你会有好offer的，我看好你呦\\n&quot;);\n        \n    &#125;else&#123;\n        printf(&quot;早点卷铺盖回家走人，搬砖去吧&quot;);\n    \n    &#125;\n\n    return 0;\n\n\n&#125;\n\n\n\n\n7.循环语句有些事必须一直做，比如每天都要吃饭，都要睡觉，日复一日，年复一年。\n\n还比如：\n\n\nC语言循环语句有三种\n\nfor\nwhile\ndo…while\n\n**    先看代码    **\n#include &lt;stdio.h&gt;\n\nint mian()&#123;\n\n    int line &#x3D; 0;\n\n\n    &#x2F;&#x2F;for循环演示\n    for(line &#x3D; 0; line &lt;&#x3D; 20000;line++)&#123;\n\n        printf(&quot;我要继续努力敲代码\\n&quot;);\n    \n    &#125;\n\n    if(line&gt;20000)&#123;\n\n        printf(&quot;好offer\\n&quot;);\n\n    &#125;\n\n\n    &#x2F;&#x2F;while循环演示\n    while(line &lt;&#x3D; 20000) &#123;\n        line++;\n        printf(&quot;我要继续努力敲代码\\n&quot;);\n    &#125;\n\n    if(line&gt;20000)&#123;\n\n        printf(&quot;好offer\\n&quot;);\n\n    &#125;\n\n\n    &#x2F;&#x2F;do...while循环演示\n    do&#123;\n        line++;\n        printf(&quot;我要继续努力敲代码\\n&quot;);\n    \n    &#125;while(line &lt;&#x3D; 20000);\n    \n    if(line&gt;20000)&#123;\n\n        printf(&quot;好offer\\n&quot;);\n\n    &#125;\n\n    return 0;    \n\n&#125;\n\n\n\n\n\n\n\n\n\n\n\n\n总结三种循环的判断方式：举个栗子🌰， 你有一个女朋友，前两种循环呢是先判断她是不是你女朋友，是：干羞羞的事情。   不是：走人。 那么do….while循环呢 。是先干羞羞的事情再判断是不是你女朋友（手动dog）是：接着干。不是：赶紧穿上裤子跑路。\n****\n\n8.函数函数的作用就是将反复使用的代码片段独立出去，这样可以通过调用函数来执行这些代码，可以简化代码，提高代码复用性。\n\n\n\n    栗子🌰\n\n#include &lt;stdio.h&gt;\n\n\n\nint add(int a, int b)&#123;  &#x2F;&#x2F;int 是函数的返回类型，通过实际需求自行设计，小括号里的是参数，将想要进行求和的数传进函数来\n\n    int sum &#x3D; 0;\n\n    sum &#x3D; a + b;\n\n    return sum;    &#x2F;&#x2F;返回值，需要对应函数的返回类型\n&#125;\n\n\nint main()&#123;\n\n\n    int num1 &#x3D; 10;\n\n    int num2 &#x3D; 20;\n\n    int sum &#x3D; 0;\n\n    sum &#x3D; add(num1, num2);\n    \n    printf(&quot;num1 + num2 &#x3D; %d\\n&quot;,sum);\n\n    return 0;\n\n    \n&#125;\n\n\n\n\n9.数组假如我们要存储10数据，怎么办呢！\n\n\n\n    有同学说，我们可以定义十次。（int sum1; int sum2;int sum3........）（嗯，可行）但是如果我们要存储一万个数据呢（![](https:&#x2F;&#x2F;img-blog.csdnimg.cn&#x2F;6b3ab25e329d49f6aa6743d7ade5ba2a.jpeg)![]( &quot;点击并拖拽以移动&quot;)**编辑**你要不要看看你在说什么？？？），这个时候就要用到数组了。\n\n9.1 数组定义\n\n\n\n\n\n\n\n\nint arr[10] &#x3D; {1,2,3,4,5,6,7,8,9,10}; &#x2F;&#x2F;定义一个整形数组，最多放十个元素，arr是数组名，可自行选择（但要遵循变量名命名规则，3.2中讲过）\n9.2 数组的下标\n\n\n\n\n\n\n\n\n\n数组的下标是从0开始的\n数组可以通过下标来访问的。\n\n比如：\n\n\n\n\n\n\n\n\n\nint arr[10] &#x3D; {0}; &#x2F;&#x2F; 全部初始化为0\n\n9.3 数组的使用#include &lt;stdio.h&gt;\n\n\nint main()&#123;\n\n    int arr[10] &#x3D; &#123;1,2,3,4,5,6,7,8,9,10&#125;;\n\n    for(int i &#x3D; 0;i &lt; 10; i++)&#123;\n\n\n        printf(&quot;%d &quot;,arr[i]);    \n    &#125;\n    \n    printf(&quot;\\n&quot;);\n    return 0;\n&#125;\n\n\n\n运行结果如下：\n\n\n10. 操作符（简单介绍几个，后续进阶会讲，主要怕你们从入门到放弃啊算术操作符\n\n\n\n\n\n\n\n\n\n\n+ \n- \n\n乘法\n\n&#x2F;  除法\n% 取模&#x2F;取余数    比如   5%2     这个表达式结果是1\n移位操作符\n\n\n\n\n\n\n\n\n\n\n\n\n&lt;&lt;\n\n\n位操作符\n\n\n\n\n\n\n\n\n\n\n&amp;     ^     |\n赋值操作符\n\n\n\n\n\n\n\n\n\n\n&#x3D;     +&#x3D;    -&#x3D;   *&#x3D;   &#x2F;&#x3D;   &amp;&#x3D;    ^&#x3D;    |&#x3D;    &gt;&gt;&#x3D;    &lt;&lt;&#x3D;\n单目操作符\n\n\n\n\n\n\n\n\n\n\n! 逻辑反操作\n\n负值\n\n\n正值\n\n&amp; 取地址\nsizeof 操作数的类型长度(以字节为单位)\n~ 对一个数的二进制按位取反\n– 前置、后置–\n++ 前置、后置++     比如：a++ 或者 ++a  那么a的值就在原来基础上+1\n\n间接访问操作符(解引用操作符)\n\n(类型) 强制类型转换\n关系操作符\n\n\n\n\n\n\n\n\n\n\n\n大于\n\n\n\n\n\n\n\n\n\n&#x3D; 大于等于\n&lt; 小于\n&lt;&#x3D; 小于等于\n!&#x3D; 不等于\n&#x3D;&#x3D; 相等\n\n逻辑操作符\n\n\n\n\n\n\n\n\n\n\n&amp;&amp;  逻辑与    如： exp1 &amp;&amp; exp2    两边都为真才为真\n||     逻辑或    如： exp1 &amp;&amp; exp2    两边有一个真就为真\n条件操作符\n\n\n\n\n\n\n\n\n\n\nexp1？ exp2 : exp3\n逗号表达式\n\n\n\n\n\n\n\n\n\n\nexp1,exp2,exp3….expn\n下标引用、函数调用和结构成。\n\n\n\n\n\n\n\n\n\n\n[ ]     ()      .      -&gt;\n\n11. 常见关键字C90标准中，有32个关键字，分别是 （这么多 ![](https:&#x2F;&#x2F;img-blog.csdnimg.cn&#x2F;2038c491ad6248c48c67b9545646b35b.webp)![]( &quot;点击并拖拽以移动&quot;)**编辑**）（不要害怕！）\n\n\n\n\n\n\n\n\n\n\n\nauto double int struct break  else  long  switch  case enum register typedef char extern return union const float short unsigned continue for signed void default goto sizeof volatile do if while static\nC99中37个，新增5个\n\n\n\n\n\n\n\n\n\n\ninline 内联函数           restrict 用于限定指针        _Bool  定义布尔类型变量（1真0假）         _Complex  定义复数类型             _Imaginary 定义虚数类型\nC语言提供了丰富的关键字，这些关键字都是语言本身预先设定好的，用户自己是不能创造关键字的。\n\n\n\n    注:关键字，先介绍下面几个，后期遇到讲解。\n\n11.1 关键字 typedef\n\n\n\n\n\n\n\n\ntypedef顾名思义就是类型定义，这里可以理解为类型重命名\n看栗子🌰\n\n&#x2F;&#x2F;将unsigned int 重命名为uint_32, 所以uint_32也是一个类型名 \n\ntypedef unsigned int uint_32;\n\nint main()&#123;\n\n    &#x2F;&#x2F;观察num1和num2,这两个变量的类型是一样的 \n    unsigned int num1 &#x3D; 0;\n    uint_32 num2 &#x3D; 0;\n\n    return 0;\n&#125;\n\n\n\n11.2关键字static\n\n\n\n\n\n\n\n\n在C语言中: static是用来修饰变量和函数的\n\n修饰局部变量-称为静态局部变量\n修饰全局变量-称为静态全局变量\n修饰函数-称为静态函数\n\n11.2.1 修饰局部变量&#x2F;&#x2F;代码一\n#include &lt;stdio.h&gt;\n\nvoid test()&#123;\n\n    int i &#x3D; 0;\n    i++;\n    printf(&quot;%d &quot;,i);\n\n&#125;\n\nint main()&#123;\n\n\n    for(int k &#x3D; 0; k&lt; 10; k++)&#123;\n\n        test();\n\n    &#125;\n    return 0;\n&#125;\n\n\n&#x2F;&#x2F;代码二\n\n#include &lt;stdio.h&gt;\n\nvoid test()&#123;\n\n    static int i &#x3D; 0;\n    i++;\n\n    printf(&quot;%d &quot;,i);\n\n&#125;\n\nint main()&#123;\n\n\n    for(int k &#x3D; 0; k&lt; 10; k++)&#123;\n\n        test();\n\n    &#125;\n\n    return 0;\n&#125;\n\n&#x2F;&#x2F;代码一输出 1 1 1 1 1 1 1 1 1 1\n&#x2F;&#x2F;代码二输出 1 2 3 4 5 6 7 8 9 10\n\n&#x2F;&#x2F;代码三 如果我们在主函数内是有 i行不行呢\n\n#include &lt;stdio.h&gt;\n\nvoid test()&#123;\n\n    static int i &#x3D; 0;\n    i++;\n\n    printf(&quot;%d &quot;,i);\n\n&#125;\n\nint main()&#123;\n\n\n    for(int k &#x3D; 0; k&lt; 10; k++)&#123;\n\n        test();\n\n    &#125;\n    \n    printf(&quot;%d\\n&quot;,i); &#x2F;&#x2F;这是不行的，i的作用域依然是局部的智能在test函数内部使用\n\n    return 0;\n&#125;\n\n\n\n对比代码1和代码2的效果理解static修饰局部变量的意义。\n\n结论:\n\n\n\n\n\n\n\n\n\nstatic修饰局部变量，只定义一次。 并且出代码块也不会被释放。（所以修饰局部变量，相当于将该局部变量生命周期变为整个工程期间，但是作用域不变。依然只能在代码块内使用）\n11.2.2 修饰全局变量&#x2F;&#x2F;代码一\n\n文件add.c\n\nint g_val &#x3D; 10;\n\n文件test.c\n\n#include &lt;stdio.h&gt;\n\nint main()&#123;\n\n    printf(&quot;%d\\n&quot;,g_val); &#x2F;&#x2F;可行\n\n&#125;\n\n\n&#x2F;&#x2F;代码二\n\n文件add.c\n\nstatic int g_val &#x3D; 10;\n\n文件test.c\n\n#include &lt;stdio.h&gt;\n\nint main()&#123;\n\n    printf(&quot;%d\\n&quot;,g_val); &#x2F;&#x2F;不可行\n\n&#125;\n\n\n\n代码1正常，代码2在编译的时候会出现连接性错误。\n\n结论:\n\n\n\n\n\n\n\n\n\n一个全局变量被static修饰，使得这个全局变量只能在本源文件内使用，不能在其他源文件内使用。\n11.2.3 修饰函数&#x2F;&#x2F;代码一\n\n文件add.c\n\nint add(int a, int b)&#123;\n\n    return a + b;\n&#125;\n\n文件test.c\n\n#include &lt;stdio.h&gt;\n\nint main()&#123;\n\n    printf(&quot;%d\\n&quot;,add(5,8)) &#x2F;&#x2F;可行\n\n&#125;\n\n\n&#x2F;&#x2F;代码二\n\n文件add.c\n\nstatic int add(int a, int b)&#123;\n\n    return a + b;\n&#125;\n\n文件test.c\n\n#include &lt;stdio.h&gt;\n\nint main()&#123;\n\n    printf(&quot;%d\\n&quot;,add(5,8)) &#x2F;&#x2F;不可行\n\n&#125;\n\n\n\n代码1正常，代码2在编译的时候会出现连接性错误.\n\n结论:\n\n\n\n\n\n\n\n\n\n函数被static修饰，使得这个函数只能在本源文件内使用，不能在其他源文件内使用。\n其他关键字后续C语言进阶讲\n\n\n\n12. #define 定义常量和宏先看栗子🌰\n&#x2F;&#x2F;define 定义标识符常量\n\n#define MAX 1000 &#x2F;&#x2F;MAX是常量名  1000是值（注意语句后不要加 ; 因为看到很多初学者加 ; 特意提一句）\n\n&#x2F;&#x2F;define定义宏\n\n#define ADD(x, y) ((x) + (y))\n\n#include &lt;stdio.h&gt;\n\nint main()&#123;\n\n    int arr[MAX] &#x3D; &#123;0&#125;; &#x2F;&#x2F; 这是可行的，因为MAX是常量\n\n    int sum &#x3D; ADD(2,3);\n    printf(&quot;sum &#x3D; %d\\n&quot;,sum); &#x2F;&#x2F; 打印5\n\n    sum &#x3D; 10 * ADD(2,3);\n    printf(&quot;sum &#x3D; %d\\n&quot;,sum); &#x2F;&#x2F; 打印50\n\n    return 0;\n&#125;\n\n\n\n\n13. 指针13.1 内存\n\n\n\n\n\n\n\n\n内存是电脑上特别重要的存储器，计算机中程序的运行都是在内存中进行的 。所以为了有效的使用内存，就把内存划分成一个个小的内存单元，每个内存单元的大小是 **1个字节** 。为了能够有效的访问到内存的每个单元，就给内存单元进行了编号，这些编号被称为该**内存单元的地址。**\n**看图：**\n\n\n所有变量本质都是要在内存的某个位置开辟空间的！（每个内存单元都有地址，所以变量也是有地址的）假设我们定义一个int型 变量a。\n\n\n取出变量地址如下：\n#include &lt;stdio.h&gt;\n\nint mian()&#123;\n\n    int a &#x3D; 0;\n\n    &amp;a; &#x2F;&#x2F;这就是将a的地址取出来 ,int的大小是4个字节，取地址只取首个字节的地址\n\n    printf(&quot;%p\\n&quot;,&amp;a); &#x2F;&#x2F;%p 是以地址的形式打印\n\n    return 0;\n\n&#125;\n\n\n\n那么地址如何存储呢？（这个时候我们就需要指针变量）\n\n\n\n\n\n\n\n\n\nint a &#x3D; 10;\nint *p; &#x2F;&#x2F;p为一个整形指针变量\np &#x3D; &amp;a;\n指针使用栗子🌰\n\n\n\n\n\n\n\n\n\nint a &#x3D;10;\nint *p;\np &#x3D; &amp;a;\n*p &#x3D; 20; &#x2F;&#x2F;这里将a的值改为20\n以整形指针举例，可以推广到其他类型，如:\n\n\n\n\n\n\n\n\n\n#include &lt;stdio.h&gt;\nint main(){\nchar ch &#x3D; &#39;a&#39;;\n\n\n\n char * p &#x3D; &amp;ch;\n\n\n\n *p &#x3D; &#39;q&#39;;  &#x2F;&#x2F;将char型变量 ch的值改为q\n\n\n\n return 0;\n\n}\n13.2 指针变量的大小&#x2F;&#x2F;指针变量的大小取决于地址的大小 &#x2F;&#x2F;32位平台下地址是32个bit位(即4个字节) &#x2F;&#x2F;64位平台下地址是64个bit位(即8个字节)\n#include &lt;stdio.h&gt;\n\nint main() &#123;\n    printf(&quot;%d\\n&quot;, sizeof(char *));    4&#x2F;8\n    printf(&quot;%d\\n&quot;, sizeof(short *));   4&#x2F;8\n    printf(&quot;%d\\n&quot;, sizeof(int *));     4&#x2F;8\n    printf(&quot;%d\\n&quot;, sizeof(double *));  4&#x2F;8\n    return 0;\n&#125;\n\n\n\n**    结论:指针大小在32位平台是4个字节，64位平台是8个字节。 **\n\n\n14. 结构体\n\n\n\n\n\n\n\n\n结构体是C语言中特别重要的知识点，结构体使得C语言有能力描述复杂类型。比如描述学生，学生包含: 名字+年龄+性别+学号 这几项信息。这里只能使用结构体来描述了。\n例如:\n\n\n\n\n\n\n\n\n\nstruct Stu{\nchar name[20];  &#x2F;&#x2F; 姓名\n\n\n\n int age;              &#x2F;&#x2F;年龄          \n\n\n\n char sex[5];       &#x2F;&#x2F;性别 \n\n\n\n char id[20];        &#x2F;&#x2F;学号\n\n};\n结构体的初始化 ,看代码\n#include &lt;stdio.h&gt;\n\n\nstruct Stu&#123;\n\n     char name[20];  &#x2F;&#x2F; 姓名\n\n     int age;              &#x2F;&#x2F;年龄          \n\n     char sex[5];       &#x2F;&#x2F;性别 \n\n     char id[20];        &#x2F;&#x2F;学号\n\n&#125;;\n\n\nint main()&#123;\n\n    &#x2F;&#x2F;结构体变量的定义及初始化\n    struct Stu s &#x3D; &#123;&quot;蔡徐坤&quot;,20,男,&quot;20221018&quot;&#125;;\n\n    &#x2F;&#x2F;打印结构体变量成员     .为结构体成员访问操作符\n    printf(&quot;姓名：%s\\n 年龄：%d\\n 性别：%s\\n 学号：%s\\n&quot;,s.name,s.age,s.sex,s.id);\n\n\n    &#x2F;&#x2F;结构体指针\n\n    struct Stu *ps &#x3D; &amp;s;\n    &#x2F;&#x2F;-&gt; 操作符\n    printf(&quot;姓名：%s\\n 年龄：%d\\n 性别：%s\\n 学号：%s\\n&quot;,ps-&gt;name,ps-&gt;age,ps-&gt;sex,ps-&gt;id);\n\n\n\n\n\n&#125;\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n🎬如果你刚步入计算机世界，并且认真看到这里，那么希望本文能对你有所帮助，如果你觉得文章不错的话，\n可以关注博主，博主后续会不断更新更优质的文章来分享博主的学习心得，也希望能够让在编程路上遇到困难的小伙伴获得一些帮助。\n","slug":"C语言万字文章入门","date":"2023-02-18T13:18:50.000Z","categories_index":"","tags_index":"C语言","author_index":"混游"},{"id":"b9663f58f18133b35bfe243f3e916a80","title":"Hello World","content":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub.\nQuick StartCreate a new post$ hexo new &quot;My New Post&quot;\n\nMore info: Writing\nRun server$ hexo server\n\nMore info: Server\nGenerate static files$ hexo generate\n\nMore info: Generating\nDeploy to remote sites$ hexo deploy\n\nMore info: Deployment\n","slug":"hello-world","date":"2022-11-25T10:53:51.000Z","categories_index":"","tags_index":"git","author_index":"混游"}]